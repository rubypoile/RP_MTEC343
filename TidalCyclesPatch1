setcps (66/60/2)
d1 $ slice 16 "[~ 1 ~ 4 ~ 12 8 11 1 3 5 7 9 11 13 15]" $ s "breaks125:1" # gain 1.2
d3 $ slice 16 "[~ ~ 2 ~ ~ 2 ~ ~ 4 ~ ~ ~ 3 ~ 16 16 ~ ~ 2 ~ ~ 2 ~ ~ 4 ~ ~ ~ 3 ~ 9 9]*0.5" $ s "breaks125:1"*|0.5 # gain 1.2
d4 $ note (arp "converge*4" "<d'major a'major>") # s "newnotes"*|0.25 # gain 1.6 # squiz "[0.5|1]"
d2 $ s "drumtraks:6*2"*|0.6 # crush "[7|8|9|6]" # gain 3
d5 $ slice 16 "[12 1 16 1 10 3 3 11 12 1 14 14 10 6 6 11]*0.25" $ s "bev" # djf sine # gain 1.8 # release 0.6
d6 $ slice 16 "[1 ~ 1 ~ 6 ~ 8 ~]*0.25" $ s "bev"*|0.5 # squiz "1" # djf sine # gain 2 # release 5.4
d5 $ slice 16 "[1 ~ 1 6 5 ~ 5 ~ 4 ~ 4 ~ ~ 3 ~ 3 1 ~ 1 6 7 ~ 7 ~ 12 13 4 3 ~ 3 3 3]*0.125" $ s "bev" # crush "8" # gain 1.8 # attack 0.1 # hold 0.66 # release 0.9
d6 $ slice 16 "[3 ~ 3 ~ 2 ~ 2 ~ 3 ~ 11 ~ 12 ~ 6 ~]*0.25" $ s "bev"*|0.5 # squiz "1" # gain 1.3 # release 3.6 # lpf 666 
d1 $ slice 16 "[1 2 1 2 4 1 2 3]" $ s "breaks125:1"*|0.5 # gain 1.3  # lpf 1236
d3 $ slice 16 "[2 1]*4" $ s "breaks125:1" # gain 1.4  
d5 $ slice 12 "[3 ~ 3 ~ 2 ~ 2 ~ 3 ~ 11 ~ 12 ~ 6 ~]" $ s "bev"*|0.5 # squiz "1" # gain 1.8 # release 0.5

d1 $ silence
d2 $ silence
d3 $ silence
d4 $ silence
d5 $ silence
d6 $ silence
hush




So as far as documentation goes, I started out by creating a simple framework for the different drums based on functionality, and their role within the larger movement of the music. 
Then I figured out what sounded nice within each pattern and moved on to doing the same thing with the song sample, and slicing it up to find ways in which I could layer two version of it,
one at normal pitch, and another 2 octaves lower. I spent some time finding different audio effects that added nice layers of texture over large manipulation, and then created secondary
patterns to switch to for both drum parts and the sampled parts, and I think it flows really well even without fades and stuff. I also built a small list of silences to give me some more
performatice control and I think the result is quite nice. 
